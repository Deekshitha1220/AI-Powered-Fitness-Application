# AI-Powered-Fitness-Application
Fitness Microservices Project with Spring Boot, React, and AI
Table of Contents
1. Introduction
2. Features
3. Architecture
4. Tech Stack
5. Setup Instructions
    ◦ Prerequisites
    ◦ 1. Clone the Repository
    ◦ 2. Database & Messaging Setup (using Docker)
    ◦ 3. Keycloak Configuration
    ◦ 4. Google Gemini API Key
    ◦ 5. Backend Microservices Setup (IntelliJ IDEA)
    ◦ 6. Frontend Application Setup (Visual Studio Code)
6. How to Run
7. Testing with Postman
--------------------------------------------------------------------------------
1. Introduction
This project is a full-fledged fitness application built with a microservices architecture, featuring a Spring Boot backend, a React frontend, and AI integration. Its primary goal is to provide users with a platform to log their fitness activities and receive personalized health and workout recommendations generated by artificial intelligence. The project demonstrates how to build robust, scalable, and secure microservices using modern technologies, covering concepts like inter-service communication, centralized configuration, service discovery, API Gateway, and OAuth 2.0 authentication with Keycloak.
2. Features
• User Management: Handles user registration, validation, and synchronization with Keycloak, serving as an extended user profile service.
• Activity Tracking: Allows users to log various fitness activities (e.g., running, walking, cycling, weight training) along with details such as duration, calories burned, start time, and additional metrics.
• AI-Powered Recommendations: Generates personalized health plans and workout suggestions based on the user's tracked activity data using the Google Gemini API.
• Microservices Architecture: Decomposes the application into several independent services: User, Activity, AI, Eureka Server, Config Server, and API Gateway.
• Frontend Interface: A user-friendly React application for logging activities, viewing historical data, and accessing AI-generated recommendations.
• Asynchronous Communication: Employs RabbitMQ for event-driven messaging between the Activity and AI services, ensuring non-blocking and decoupled processing of AI recommendations.
• Synchronous Communication: The Activity Service communicates synchronously with the User Service to validate user existence for activity logging.
• Centralized Configuration: Utilizes Spring Cloud Config Server to manage application properties for all microservices from a single repository.
• Service Discovery: Leverages Eureka Server to allow microservices to register themselves and discover other services dynamically by name.
• API Gateway: Implements Spring Cloud Gateway as a single entry point for all external client requests, handling routing, security, and user synchronization.
• Security: Integrates Keycloak as an Open Source Identity and Access Management (IAM) system, enforcing OAuth 2.0 authentication (PKCE flow) for securing API endpoints.
• Multiple Database Support: Demonstrates the use of different database technologies for different microservices; PostgreSQL for the User Service and MongoDB for the Activity and AI Services.
3. Architecture
The project follows a microservices architecture, where functionalities are separated into distinct services.
• Client (React Frontend): Interacts with the backend via the API Gateway.
• API Gateway (Spring Cloud Gateway): The single entry point for all external requests. It handles request routing to the appropriate microservice, applies security checks using Keycloak, and performs user synchronization.
• Keycloak: Acts as the Identity Provider (IdP), managing user authentication, authorization, and issuing JWT access tokens.
• User Service (Spring Boot): Manages user profiles and stores extended user information in a PostgreSQL database. It is synchronized with Keycloak user IDs.
• Activity Service (Spring Boot): Responsible for tracking and storing user fitness activities in a MongoDB database. It communicates with the User Service for user validation and publishes activity events to RabbitMQ.
• AI Service (Spring Boot): Consumes activity events from RabbitMQ, calls the Google Gemini API to generate personalized recommendations, and stores these recommendations in its own MongoDB database.
• Eureka Server (Spring Cloud Netflix Eureka): A discovery server where all microservices register themselves, allowing for dynamic service location.
• Config Server (Spring Cloud Config): Provides centralized management of configuration properties for all microservices, ensuring consistency and ease of updates.
• RabbitMQ: An asynchronous message broker used to decouple the Activity Service from the AI Service, ensuring that AI recommendation generation does not block activity logging.
4. Tech Stack
Backend:
• Framework: Spring Boot
• Language: Java (JDK 23/21)
• Build Tool: Maven
• Microservices Components:
    ◦ Spring Cloud Netflix Eureka (Service Discovery)
    ◦ Spring Cloud Gateway (API Gateway)
    ◦ Spring Cloud Config Server (Centralized Configuration)
    ◦ Spring WebFlux (Reactive programming, WebClient for inter-service communication)
• Databases:
    ◦ PostgreSQL (User Service)
    ◦ MongoDB (Activity Service, AI Service)
• Messaging: RabbitMQ (Asynchronous Communication)
• Authentication/Authorization: Keycloak (Open Source IAM, OAuth 2.0 PKCE Flow)
• AI Integration: Google Gemini API
• Containerization Tools (optional for microservices, used for Infra): Docker, Buildpacks, Jib
Frontend:
• Framework: React
• Build Tool: Vite (pronounced "Vee-t")
• State Management: React Redux / Redux Toolkit
• UI Library: Material UI
• API Client: Axios
• Routing: React Router DOM
Assisted Development: Enhanced with AI (Cursor AI) to speed up implementation
• Authentication: react-oauth2-code-pkce
Development Tools:
• Backend IDE: IntelliJ IDEA Ultimate (recommended)
• Frontend IDE: Visual Studio Code (recommended)
• API Testing: Postman
6. Setup Instructions
Prerequisites
Before you begin, ensure you have the following installed on your system:
• Java Development Kit (JDK): Version 23 or a compatible version (e.g., 21).
• Maven: A build automation tool.
• Docker Desktop: Essential for running RabbitMQ and Keycloak containers.
• Node.js and npm: Required for the React frontend application.
• IntelliJ IDEA Ultimate: Recommended for backend development.
• Visual Studio Code: Recommended for frontend development.
• Postman: For testing API endpoints and OAuth 2.0 flows.
1. Clone the Repository
git clone <repository_url>
cd <project_root_directory>
2. Database & Messaging Setup (using Docker)
• PostgreSQL:
    ◦ The User Service connects to localhost:5432. You can either install PostgreSQL locally or run it via Docker. A pgAdmin GUI is recommended for database management.
• MongoDB:
    ◦ The Activity and AI Services use MongoDB. You can install MongoDB Community Server locally and use MongoDB Compass GUI for management.
    ◦ Alternatively, you can use a free tier on MongoDB Atlas and configure the connection string in the respective service's configuration.
    ◦ Start local MongoDB Service: If installed locally, ensure the MongoDB service is running on your system.
• RabbitMQ:
    ◦ Run RabbitMQ with its management console using Docker:
    ◦ This command starts RabbitMQ, maps port 5672 for AMQP, and 15672 for the web management UI.
    ◦ Access the RabbitMQ Management UI: Open http://localhost:15672 in your browser. Log in with default credentials guest/guest.
    ◦ Create Exchange: Navigate to "Exchanges" and add a new exchange named fitness.exchange of type direct.
• Keycloak:
    ◦ Run Keycloak using Docker:
    ◦ This starts Keycloak and maps port 8080 inside the container to 8181 on your host machine.
    ◦ Access the Keycloak Admin Console: Open http://localhost:8181 in your browser. Log in with default credentials admin/admin.
3. Keycloak Configuration
1. Create a Realm:
    ◦ In the Keycloak Admin Console, hover over "Master" and click "Add realm".
    ◦ Name the new realm fitness-o2.
2. Create a Client:
    ◦ Navigate to the fitness-o2 realm. In the left sidebar, click "Clients".
    ◦ Click "Create client".
    ◦ Set Client type to OpenID Connect.
    ◦ Set Client ID to o2-pkce-client.
    ◦ Click "Next".
    ◦ Enable Standard Flow and Direct Access Grants.
    ◦ Set Root URL to http://localhost:5173.
    ◦ Set Redirect URIs to http://localhost:5173/*.
    ◦ Set Web Origins to http://localhost:5173.
    ◦ Click "Save".
    ◦ After saving, go to the "Advanced" tab for the client and set PKCE Code Challenge Method to S256 from the dropdown. Save changes.
3. Create a User:
    ◦ In the fitness-o2 realm, navigate to "Users".
    ◦ Click "Add user". Create a user, for example:
        ▪ Username: user1
        ▪ Email: user1@example.com
        ▪ First Name: User1
        ▪ Last Name: Last1
    ◦ Click "Create".
    ◦ Go to the "Credentials" tab for the newly created user.
    ◦ Set a password, e.g., password1. Ensure "Temporary" is OFF. Click "Set Password" and then "Save".
4. Google Gemini API Key
1. Visit the Google AI Studio website.
2. Navigate to "Explore models in Google AI Studio" and obtain an API key.
3. Configure for AI-Service: In your IntelliJ IDEA, for the AI-Service run configuration, add the Gemini API URL and your API key as environment variables. The format should be:
4. Replace <YOUR_GEMINI_API_KEY> with your actual key.
5. Backend Microservices Setup (IntelliJ IDEA)
1. Open Project: Open the parent project directory (e.g., fitness-microservices) in IntelliJ IDEA.
2. Maven Configuration:
    ◦ Ensure all sub-projects (microservices) are recognized as Maven projects. If not, right-click on the pom.xml of each service and select "Load Maven Project" or "Add as Maven Project".
    ◦ Ensure the spring-cloud.version is defined in the <properties> section and spring-cloud-dependencies are present in <dependencyManagement> of each service's pom.xml if it uses Spring Cloud components.
    ◦ Lombok: Go to File -> Settings -> Build, Execution, Deployment -> Compiler -> Annotation Processors. Enable "Enable annotation processing" and select "Obtain processors from project classpath" for all microservices. Rebuild projects if you encounter getter/setter errors.
3. Config-Server:
    ◦ Port: Set server.port=8888 in config-server/src/main/resources/application.yaml.
    ◦ Enable Config Server: Add @EnableConfigServer annotation to the ConfigServerApplication.java main class.
    ◦ Configuration Files: Create a directory config-server/src/main/resources/config.
    ◦ Move the application.yaml files from all other microservices into this config directory. Rename each file to <service-name>.yaml (e.g., user-service.yaml, activity-service.yaml, ai-service.yaml, api-gateway.yaml). Remove the spring.application.name property from these individual YAMLs, as it will be inferred.
    ◦ Search Locations: In config-server/src/main/resources/application.yaml, configure spring.cloud.config.server.native.search-locations=classpath:/config/ to point to your new configuration directory.
4. Eureka-Server:
    ◦ Port: Set server.port=8761 in its application.yaml.
    ◦ Enable Eureka Server: Add @EnableEurekaServer annotation to EurekaServerApplication.java.
    ◦ Self-Registration: Set eureka.client.register-with-eureka=false and eureka.client.fetch-registry=false in its application.yaml as it's the server itself.
5. User-Service:
    ◦ Port: Set server.port=8081.
    ◦ Config Client: Add spring-cloud-starter-config dependency to pom.xml. Configure spring.config.import=optional:configserver:http://localhost:8888 in application.yaml. Remove other local configurations.
    ◦ Database: Ensure spring.datasource properties for PostgreSQL are correctly configured in user-service.yaml on the Config Server.
    ◦ Model Update: Add a private String keycloakId; field to the User model to store Keycloak's unique user ID.
    ◦ Repository Update: Update UserRepository to include existsByKeycloakId(String keycloakId) and findByEmail(String email) methods.
6. Activity-Service:
    ◦ Port: Set server.port=8082.
    ◦ Config Client: Add spring-cloud-starter-config dependency to pom.xml. Configure spring.config.import=optional:configserver:http://localhost:8888 in application.yaml. Remove other local configurations.
    ◦ Messaging: Add spring-boot-starter-amqp (RabbitMQ) dependency to pom.xml.
    ◦ Database: Ensure spring.data.mongodb properties for MongoDB are correctly configured in activity-service.yaml on the Config Server.
    ◦ RabbitMQ Config: Create a RabbitMQConfig class with @Configuration to define Queue, DirectExchange, Binding, and Jackson2JsonMessageConverter beans.
    ◦ Service Logic: Inject RabbitTemplate and publish SavedActivity objects to RabbitMQ after saving them to the database. In the trackActivity method, add @RequestHeader("X-User-ID") String userId to receive the user ID from the API Gateway.
7. AI-Service:
    ◦ Port: Set server.port=8083.
    ◦ Config Client: Add spring-cloud-starter-config dependency to pom.xml. Configure spring.config.import=optional:configserver:http://localhost:8888 in application.yaml. Remove other local configurations.
    ◦ Messaging: Add spring-boot-starter-amqp (RabbitMQ) dependency to pom.xml.
    ◦ Reactive Web: Add spring-boot-starter-webflux dependency to pom.xml for WebClient.
    ◦ Database: Ensure spring.data.mongodb properties for MongoDB are correctly configured in ai-service.yaml on the Config Server.
    ◦ RabbitMQ Config: Copy the RabbitMQConfig class from the activity-service.
    ◦ Listener: Create an ActivityMessageListener class with @RabbitListener to consume messages from activity.q.
    ◦ AI Logic: Implement GeminiService for making HTTP calls to the Google Gemini API. Create ActivityAIService to process consumed activities, generate prompts, call GeminiService, parse the AI response, and save recommendations to MongoDB.
8. API-Gateway:
    ◦ Port: Set server.port=8080.
    ◦ Config Client: Add spring-cloud-starter-config dependency to pom.xml. Configure spring.config.import=optional:configserver:http://localhost:8888 in application.yaml. Remove other local configurations.
    ◦ Dependencies: Add spring-cloud-starter-gateway (ensure it's the reactive one, not MVC), spring-cloud-starter-netflix-eureka-client, spring-cloud-starter-oauth2-resource-server, and lombok to pom.xml.
    ◦ Eureka Client: @EnableDiscoveryClient (implicitly enabled by Eureka client dependency).
    ◦ Routing: Define routes in api-gateway.yaml (on Config Server) for user-service, activity-service, and ai-service. Use lb://<service-name> for load-balanced routing.
    ◦ Security Configuration: Create a SecurityConfig.java class with @Configuration and @EnableWebFluxSecurity. Configure OAuth2ResourceServer (JWT) and enable CORS for http://localhost:5173.
    ◦ User Synchronization Filter: Create a KeycloakUserSyncFilter.java class that implements WebFilter. This filter will intercept requests, extract the JWT token, decode it to get the Keycloak User ID, query the User Service to check if the user exists in the local database, and register the user if they are new. It also adds the X-User-ID header to the request.
6. Frontend Application Setup (Visual Studio Code)
1. Navigate to Directory: Open your project's root directory in Visual Studio Code. Open the integrated terminal.
2. Create React Project:
3. This creates a new React project using Vite and installs initial dependencies.
4. Install Additional Dependencies:
5. Configure Keycloak Client (src/config.js):
    ◦ Create src/config.js.
    ◦ Define oAuth2Config with your Keycloak client details (Client ID: o2-pkce-client, Authorization Endpoint, Token Endpoint, Redirect URI: http://localhost:5173, Scope: openid profile email offline_access). Get Authorization and Token endpoints from Keycloak's "OpenID Endpoint Configuration" in realm settings.
6. Redux Store Setup:
    ◦ Create src/store/store.js to configure the Redux store with configureStore from Redux Toolkit.
    ◦ Create src/store/o-slice.js to define an authentication slice (o-slice) with initial state (user, token, userId from local storage) and reducers for setCredentials and logout.
7. Integrate Providers (src/main.jsx): Wrap your App component with <Provider store={store}> (from React Redux) and <OAuth2Provider config={oAuth2Config}> (from react-oauth2-code-pkce).
8. Axios API Service (src/services/API.js):
    ◦ Create src/services/API.js.
    ◦ Configure an Axios instance with the API Gateway's base URL (http://localhost:8080/api).
    ◦ Implement an Axios request interceptor to automatically add the Authorization: Bearer <token> and X-User-ID: <keycloak-user-id> headers to all outgoing requests. These values are retrieved from local storage.
    ◦ Define functions for interacting with backend endpoints (e.g., getActivities, addActivity, getActivityDetail).
9. React Components and Routing:
    ◦ Implement React components: ActivityForm.jsx, ActivityList.jsx, ActivityDetail.jsx.
    ◦ Configure react-router-dom in src/App.jsx to handle navigation:
        ▪ A root path (/) that redirects to /activities if authenticated, otherwise displays a login prompt.
        ▪ /activities to show the ActivitiesPage (combining ActivityForm and ActivityList).
        ▪ /activities/:id to display ActivityDetail for a specific activity.
    ◦ In App.jsx, use useContext for OAuth2Context to access login/logout functions and authentication status. Use useDispatch for Redux actions.
    ◦ Implement login/logout functionality: The login button will trigger the login() function from OAuth2Context, redirecting to Keycloak. Upon successful login, the setCredentials Redux action updates the store and local storage with token and user details.
    ◦ Ensure proper passing of X-User-ID from local storage to backend requests.
6. How to Run
Follow these steps to run the entire application:
1. Start Docker Containers:
    ◦ Open your terminal and ensure Docker Desktop is running.
    ◦ Start the rabbitmq and keycloak containers:
    ◦ (If you haven't created them, run the docker run commands from section 5.2).
2. Start Backend Microservices (from IntelliJ IDEA):
    ◦ Open the fitness-microservices project in IntelliJ.
    ◦ Start each microservice application in the following order, waiting for each to fully initialize and register with Eureka before starting the next:
        1. Config-ServerApplication (http://localhost:8888)
        2. EurekaServerApplication (http://localhost:8761)
        3. UserServiceApplication (http://localhost:8081)
        4. ActivityServiceApplication (http://localhost:8082)
        5. AiServiceApplication (http://localhost:8083)
        6. ApiGatewayApplication (http://localhost:8080)
3. Start Frontend Application (from Visual Studio Code):
    ◦ Open the fitness-app-frontend directory in VS Code.
    ◦ Open the integrated terminal and run:
    ◦ Access the application in your web browser, typically at http://localhost:5173.
4. Login to the Application:
    ◦ On the frontend, click the "Login" button. You will be redirected to the Keycloak login page (http://localhost:8181).
    ◦ Enter the credentials for a user you created in Keycloak (e.g., user1/password1 or user2/password2).
    ◦ Upon successful login, you will be redirected back to the fitness application dashboard, where you can start logging activities and view recommendations.
7. Testing with Postman
1. Obtain Access Token:
    ◦ Open Postman. Go to the "Authorization" tab for any request that requires authentication.
    ◦ Select type OAuth 2.0.
    ◦ Click "Get New Access Token".
    ◦ Configure the "New Token" dialog:
        ▪ Grant Type: Authorization Code (With PKCE).
        ▪ Callback URL: https://oauth.pstmn.io/v1/callback (Postman's default).
        ▪ Auth URL: http://localhost:8181/realms/fitness-o2/protocol/openid-connect/auth.
        ▪ Access Token URL: http://localhost:8181/realms/fitness-o2/protocol/openid-connect/token.
        ▪ Client ID: o2-pkce-client.
        ▪ Code Challenge Method: S256.
        ▪ Leave other fields as default/empty.
    ◦ Click "Request Token". You will be redirected to Keycloak's login page in your browser. Enter your Keycloak user credentials (e.g., user1/password1) and grant access.
    ◦ Once authenticated, Postman will receive the token. Click "Use Token".
2. Test API Endpoints:
    ◦ With the access token applied, you can now send requests to your microservices via the API Gateway (http://localhost:8080/api/<service-endpoint>).
    ◦ Examples:
        ▪ Register Activity: POST http://localhost:8080/api/activities (with body and Authorization header).
        ▪ Get User Activities: GET http://localhost:8080/api/activities (with Authorization and X-User-ID headers).
        ▪ Get AI Recommendations for User: GET http://localhost:8080/api/ai/recommendation/user/{userId}.
        ▪ Validate User: GET http://localhost:8080/api/users/{userId}/validate.
